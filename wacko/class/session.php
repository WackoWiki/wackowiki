<?php

// - regenerate id every... 5min and randomly
// - do not read sessions older than maxlifetime
// - flash data
// - update cookies seldomly
// - sticky session variables

// 10 commands:
// ? Always regenerate a session ID (SID) when elevating privileges or changing between HTTP and HTTPS.
// - Check for suspicious activity and immediately destroy any suspect session.
// ? Store all session information server-side, never store anything except the SID in the client-side cookie.
// + Confirm SIDs aren't from an external source, and verify the session was generated by your server.
// + Don't append the SID to URLs as a GET parameter.
// - Expire sessions on the server side, don't rely on cookie expiration to end a user session.
// + Use long and unpredictable session IDs.
// ? Properly sanitize user input before setting headers with them.
// ? When a user logs out, destroy their session explicitly on the server.
// ! Check your session configuration.
// - Force users to re-authenticate on any destructive or critical actions.

// if ($_SESSION['SESSION_START_TIME'] < (strtotime("-1 hour"))
//     || $_SESSION['_USER_LAST_ACTIVITY'] < (strtotime("-20 mins")))

//	session_regenerate_id(TRUE);
//	session_write_close();
//	$backup = $_SESSION;
//	session_start();
//	$_SESSION = $backup;
//	$this->regenerationNeeded = FALSE;

abstract class Session extends ArrayObject // for concretization extend by some SessionStoreInterface'd class
{
	private $active = false;
	private $send_cookie = false;
	private $name = '';				// NB [0-9a-zA-Z]+ -- should be short and descriptive (i.e. for users with enabled cookie warnings)
	private $id = null;				// NB [0-9a-zA-Z,-]+

	public $gc_probability = 2;
	public $gc_maxlifetime = 1440;
	public $cookie_lifetime = 0;	// lifetime of the cookie in seconds which is sent to the browser. The value 0 means "until the browser is closed."
	public $cookie_path = '/';		// path to set in the session cookie
	public $cookie_domain = '';		// domain to set in the session cookie. '' for host name of the server which generated the cookie, according to cookies specification
									// .php.net - to make cookies visible on all subdomains
	public $cookie_secure = false;	// cookie should only be sent over secure connections.
	public $cookie_httponly = true;// Marks the cookie as accessible only through the HTTP protocol. This means that the cookie won't be accessible by js and such
	public $referer_check = '';
	public $cache_limiter = 'nocache';
	public $cache_expire = 180*60;	// ttl for cached session pages in seconds
	public $last_modified = 0;		// should be set before start() for cache limiters

	public function __construct()
	{
		register_shutdown_function([$this, 'terminator'], getcwd());
		parent::__construct([], parent::ARRAY_AS_PROPS);
	}

	public function toArray()
	{
		return $this->getArrayCopy();
	}

	// finishes session without saving data. Thus the original values in session data are kept. 
	public function abort()
	{
		if ($this->active)
		{
			$this->store_close();
			$this->active = false;
		}
	}

	// reinitializes a session with original values stored in session storage
	// this function requires an active session and discards changes in $_session
	public function reset()
	{
		if ($this->active)
		{
			$this->initialize();
		}
	}

	public function destroy($completely = false)
	{
		if (!$this->active)
		{
			return false;
		}

		if ($completely)
		{
			$this->_unset();
			$this->send_cookie(true); // remove
		}

		// close & unlink
		$this->store_destroy();

		$this->id = null;
		$this->active = false;
		return true;
	}

	// effectively destroy(true) + start()
	public function restart()
	{
		if (!$this->active)
		{
			return false;
		}

		$this->store_destroy();
		$this->id = null;
		$this->initialize();

		return true;
	}

	// replace the current session id with a newly generated
	// one, and keep the current session information
	public function regenerate_id($delete_old = false)
	{
		if (headers_sent())
		{
			//ERROR "Cannot regenerate session id - headers already sent"
		}
		else if ($this->active)
		{
			if ($delete_old)
			{
				$this->store_destroy();
			}

			$this->set_new_id();
			return true;
		}

		return false;
	}

	public function start($name = null, $id = null)
	{
		if ($this->active)
		{
			return true;
		}

		// allow to reuse original session name on session restarts
		if ($name || !$this->name)
		{
			// filter name
			$name = preg_replace('/[^0-9a-zA-Z]+/', '', $name);
			if (!$name || ctype_digit($name))
			{
				$name = 'DefaultSessionId';
			}
			$this->name = $name;
		}

		$this->send_cookie = 1;

		if (!$id && ($id = @$_COOKIE[$this->name]))
		{
			$this->send_cookie = 0;
		}

		if ($id && $this->referer_check
			&& strstr($_SERVER['HTTP_REFERER'], $this->referer_check) === false)
		{
			$id = null;
		}

		if ($id && !$this->store_validate_id($id))
		{
			$id = null;
		}

		$this->id = $id;
		$this->store_open($this->name);
		$this->initialize();
		$this->cache_limiter(); // TODO - why it is in the session?

		return $this->active;
	}

	public function active()
	{
		return $this->active;
	}

	public function id()
	{
		return $this->id;
	}

	public function _unset()
	{
		$this->exchangeArray([]);
	}

	// write session data, end session
	public function write_close()
	{
		if ($this->active)
		{
			$this->store_write($this->id, serialize($this->toArray()));
			// check error!
			$this->store_close();
			$this->active = false;
		}
	}

	// shutdown-registered worker
	public function terminator($cwd)
	{
		// shutdown run with cwd == /
		chdir($cwd);

		$this->write_close();

		if (Ut::rand(0, 99) < $this->gc_probability)
		{
			$this->store_gc();
			// "purged $returned expired session objects"
		}
	}

	// those two is for possible override in store methods
	protected function store_generate_id()
	{
		return Ut::random_token(21);
	}

	protected function store_validate_id($id)
	{
		return preg_match('/^[0-9a-zA-Z]{4,}$/', $id);
	}

	private function set_new_id()
	{
		$this->id = $this->store_generate_id();
		$this->send_cookie();
	}

	private function reset_id()
	{
		if ($this->send_cookie && $this->id)
		{
			$this->send_cookie();
			$this->send_cookie = 0;
		}
	}

	private function initialize()
	{
		$text = $this->store_read($this->id);

		if ($text === false)
		{
			// here we generate new session id for utterly new, or stale/evil id offered by client
			// (or file error, per se)
			$this->set_new_id();

			// create & lock new jar
			if ($this->store_read($this->id, true) !== '')
			{
				// error!
			}
		}
		else if (!$this->active)
		{
			$this->reset_id(); // STS lone use
		}

		$this->active = true;

		if (!$text || !($data = unserialize($text)))
		{
			$data = [];
		}
		$this->exchangeArray($data);
	}

	private function cache_limiter()
	{
		if (!headers_sent())
		{
			$age = $this->cache_expire;

			switch ($this->cache_limiter)
			{
				case 'public':
					header('Expires: ' . Ut::http_date(time() + $age));
					header("Cache-Control: public, max-age=$age");
					break;

				case 'private':
					header('Expires: ' . Ut::http_date(-1)); // looong ago
					// FALLTHRU

				case 'private_no_expire':
					header("Cache-Control: private, max-age=$age, pre-check=$age");
					break;

				default:
				case 'nocache':
					header('Expires: ' . Ut::http_date(-1));
					header('Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0');
					header('Pragma: no-cache');
					return; // suppress last-modified
			}

			if ($this->last_modified > 0)
			{
				header('Last-Modified: ' . Ut::http_date($this->last_modified));
			}
		}
	}

	private function remove_cookie($cookie)
	{
		$set = 'Set-Cookie';
		$clen = strlen($cookie);
		$found = 0;
		$readd = [];
		foreach (headers_list() as $name => $value)
		{
			if (!strcasecmp($name, $set))
			{
				if (!strncmp($value, $cookie, $clen) && substr($value, $clen, 1) == '=')
				{
					++$found;
				}
				else
				{
					$readd[] = $value;
				}
			}
		}
		if ($found)
		{
			header_remove($set);
			foreach ($readd as $value)
			{
				header($set . ': ' . $value);
			}
		}
	}

	private function send_cookie($remove = false)
	{
		$this->_send_cookie($this->name, ($remove? '' : $this->id));
	}

	private function _send_cookie($name, $value)
	{
		$name = rawurlencode($name);
		$this->remove_cookie($name);

		$this->setcookie($name, $value,
			($this->cookie_lifetime > 0? time() + $this->cookie_lifetime : 0),
			$this->cookie_path, $this->cookie_domain, $this->cookie_secure, $this->cookie_httponly);
	}

	public function setcookie($name, $value = '', $expires = 0, $path = '', $domain = '', $secure = false, $httponly = false, $url_encode = true)
	{
		if (headers_sent($filename, $linenum))
		{
			// ERROR "Headers already sent in $filename on line $linenum\n";
			return;
		}

		if (Ut::is_empty($value))
		{
			$expires = 1;
			$value = 'deleted';
		}

		if ($url_encode)
		{
			$value = rawurlencode($value);
		}

		if (preg_match('/[=,;\s]/', $name) || preg_match('/[,;\s]/', $value))
		{
			return false;
		}

		$cookie = 'Set-Cookie: '. $name . '=' . $value;

		if ($expires > 0)
		{
			$cookie .= '; expires=' . Ut::http_date($expires);

			if (($expires -= time()) < 0)
			{
				$expires = 0;
			}
			$cookie .= '; Max-Age=' . $expires;
		}

		if ($path)
		{
			$cookie .= '; path=' . $path;
		}
		if ($domain)
		{
			$cookie .= '; domain=' . $domain;
		}
		if ($secure)
		{
			$cookie .= '; secure';
		}
		if ($httponly)
		{
			$cookie .= '; httponly';
		}

		header($cookie, false); // false -- add, not replace

		return true;
	}
}
