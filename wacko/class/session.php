<?php

// - regenerate id every... 5min and randomly
// - do not read sessions older than maxlifetime
// - flash data
// - update cookies seldomly
// - sticky session variables

// 10 commands:
// ? Always regenerate a session ID (SID) when elevating privileges or changing between HTTP and HTTPS.
// - Check for suspicious activity and immediately destroy any suspect session.
// ? Store all session information server-side, never store anything except the SID in the client-side cookie.
// + Confirm SIDs aren't from an external source, and verify the session was generated by your server.
// + Don't append the SID to URLs as a GET parameter.
// - Expire sessions on the server side, don't rely on cookie expiration to end a user session.
// + Use long and unpredictable session IDs.
// ? Properly sanitize user input before setting headers with them.
// ? When a user logs out, destroy their session explicitly on the server.
// ! Check your session configuration.
// - Force users to re-authenticate on any destructive or critical actions.

class Session extends ArrayObject
{
	private $active = false;
	private $send_cookie = false;
	private $name = '';				// NB [0-9a-zA-Z]+ -- should be short and descriptive (i.e. for users with enabled cookie warnings)
	private $id = null;				// NB [0-9a-zA-Z,-]+

	public $save_path = '/tmp';
	public $save_mode = 0600;
	public $save_encrypt = 1;
	public $gc_probability = 2;
	public $gc_maxlifetime = 1440;
	public $cookie_lifetime = 0;	// lifetime of the cookie in seconds which is sent to the browser. The value 0 means "until the browser is closed."
	public $cookie_path = '/';		// path to set in the session cookie
	public $cookie_domain = '';		// domain to set in the session cookie. '' for host name of the server which generated the cookie, according to cookies specification
									// .php.net - to make cookies visible on all subdomains
	public $cookie_secure = false;	// cookie should only be sent over secure connections.
	public $cookie_httponly = true;// Marks the cookie as accessible only through the HTTP protocol. This means that the cookie won't be accessible by js and such
	public $referer_check = '';
	public $cache_limiter = 'nocache';
	public $cache_expire = 180*60;	// ttl for cached session pages in seconds
	public $last_modified = 0;		// should be set before start() for cache limiters

	public function __construct()
	{
		register_shutdown_function([$this, 'terminator'], getcwd());
		parent::__construct([], parent::ARRAY_AS_PROPS);
	}

	// finishes session without saving data. Thus the original values in session data are kept. 
	public function abort()
	{
		if ($this->active)
		{
			$this->jar_close();
			$this->active = false;
		}
	}

	// reinitializes a session with original values stored in session storage
	// this function requires an active session and discards changes in $_session
	public function reset()
	{
		if ($this->active)
		{
			$this->initialize();
		}
	}

	public function destroy($completely = false)
	{
		if (!$this->active)
		{
			return false;
		}

		if ($completely)
		{
			$this->_unset();
			$this->send_cookie(true); // remove
		}

		// close & unlink
		$this->jar_destroy();

		$this->id = null;
		$this->active = false;
		return true;
	}

	// replace the current session id with a newly generated
	// one, and keep the current session information
	public function regenerate_id($delete_old = false)
	{
		if (headers_sent())
		{
			//ERROR "Cannot regenerate session id - headers already sent"
		}
		else if ($this->active)
		{
			if ($delete_old)
			{
				$this->jar_destroy();
			}

			$this->set_new_id();
			return true;
		}

		return false;
	}

	public function start($name = null, $id = null)
	{
		if ($this->active)
		{
			return true;
		}

		// allow to reuse original session name on session restarts
		if ($name || !$this->name)
		{
			// filter name
			$name = preg_replace('/[^0-9a-zA-Z]+/', '', $name);
			if (!$name || ctype_digit($name))
			{
				$name = 'DefaultSessionId';
			}
			$this->name = $name;
		}

		$this->id = $id;
		$this->send_cookie = 1;

		if (!$this->id && ($this->id = @$_COOKIE[$this->name]))
		{
			$this->send_cookie = 0;
		}

		if ($this->id && $this->referer_check
			&& strstr($_SERVER['HTTP_REFERER'], $this->referer_check) === false)
		{
			$this->id = null;
		}

		if ($this->id && preg_match('/[\s<>\'"\\\\]/', $this->id))
		{
			$this->id = null;
		}

		$this->jar_construct();
		$this->initialize();
		$this->cache_limiter(); // TODO - why it is in the session?

		return $this->active;
	}

	public function active()
	{
		return $this->active;
	}

	public function id()
	{
		return $this->id;
	}

	public function _unset()
	{
		$this->exchangeArray([]);
	}

	// write session data, end session
	public function write_close()
	{
		if ($this->active)
		{
			$this->jar_write(serialize($this->getArrayCopy()));
			// check error!
			$this->jar_close();
			$this->active = false;
		}
	}

	// shutdown-registered worker
	public function terminator($cwd)
	{
		$this->write_close();

		// shutdown run with cwd == /
		chdir($cwd);

		if (Ut::rand(0, 99) < $this->gc_probability)
		{
			$this->jar_gc();
			// "purged $returned expired session objects"
		}
	}

	private function set_new_id()
	{
		$this->id = $this->generate_id();
		$this->send_cookie();
	}

	private function generate_id()
	{
		return Ut::random_token(21);
	}

	private function reset_id()
	{
		if ($this->send_cookie && $this->id)
		{
			$this->send_cookie();
			$this->send_cookie = 0;
		}
	}

	private function initialize()
	{
		$text = $this->jar_read();

		if (!$this->active)
		{
			$this->reset_id();
			$this->active = true;
		}

		$data = unserialize($text);
		$data or $data = [];
		$this->exchangeArray($data);
	}

	private function cache_limiter()
	{
		if (!headers_sent())
		{
			$age = $this->cache_expire;

			switch ($this->cache_limiter)
			{
				case 'public':
					header('Expires: ' . Ut::http_date(time() + $age));
					header("Cache-Control: public, max-age=$age");
					break;

				case 'private':
					header('Expires: ' . Ut::http_date(-1)); // looong ago
					// FALLTHRU

				case 'private_no_expire':
					header("Cache-Control: private, max-age=$age, pre-check=$age");
					break;

				default:
				case 'nocache':
					header('Expires: ' . Ut::http_date(-1));
					header('Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0');
					header('Pragma: no-cache');
					return; // suppress last-modified
			}

			if ($this->last_modified > 0)
			{
				header('Last-Modified: ' . Ut::http_date($this->last_modified));
			}
		}
	}

	private function remove_cookie($cookie)
	{
		$set = 'Set-Cookie';
		$clen = strlen($cookie);
		$found = 0;
		$readd = [];
		foreach (headers_list() as $name => $value)
		{
			if (!strcasecmp($name, $set))
			{
				if (!strncmp($value, $cookie, $clen) && substr($value, $clen, 1) == '=')
				{
					++$found;
				}
				else
				{
					$readd[] = $value;
				}
			}
		}
		if ($found)
		{
			header_remove($set);
			foreach ($readd as $value)
			{
				header($set . ': ' . $value);
			}
		}
	}

	private function send_cookie($remove = false)
	{
		$this->_send_cookie($this->name, ($remove? '' : $this->id));
	}

	private function _send_cookie($name, $value)
	{
		$name = rawurlencode($name);
		$this->remove_cookie($name);

		$this->setcookie($name, $value,
			($this->cookie_lifetime > 0? time() + $this->cookie_lifetime : 0),
			$this->cookie_path, $this->cookie_domain, $this->cookie_secure, $this->cookie_httponly);
	}

	public function setcookie($name, $value = '', $expires = 0, $path = '', $domain = '', $secure = false, $httponly = false, $url_encode = true)
	{
		if (headers_sent($filename, $linenum))
		{
			// ERROR "Headers already sent in $filename on line $linenum\n";
			return;
		}

		if (Ut::is_empty($value))
		{
			$expires = 1;
			$value = 'deleted';
		}

		if ($url_encode)
		{
			$value = rawurlencode($value);
		}

		if (preg_match('/[=,;\s]/', $name) || preg_match('/[,;\s]/', $value))
		{
			return false;
		}

		$cookie = 'Set-Cookie: '. $name . '=' . $value;

		if ($expires > 0)
		{
			$cookie .= '; expires=' . Ut::http_date($expires);

			if (($expires -= time()) < 0)
			{
				$expires = 0;
			}
			$cookie .= '; Max-Age=' . $expires;
		}

		if ($path)
		{
			$cookie .= '; path=' . $path;
		}
		if ($domain)
		{
			$cookie .= '; domain=' . $domain;
		}
		if ($secure)
		{
			$cookie .= '; secure';
		}
		if ($httponly)
		{
			$cookie .= '; httponly';
		}

		header($cookie, false); // false -- add, not replace

		return true;
	}

	// ================================================================
	// session jar

	private $jar_opened = false;
	private $jar_id = null;
	private $jar_fd = null;
	private $jar_stat;
	private $jar_key = null;

	private function jar_construct()
	{
		if (!$this->jar_opened)
		{
			if ($this->save_encrypt && extension_loaded('openssl') && extension_loaded('mbstring'))
			{
				$name = $this->name . 'Rands';
				$key = base64_decode(@$_COOKIE[$name]);
				if (mb_strlen($key, '8bit') != 64)
				{
					$key = Ut::random_bytes(64); // 32 for encryption and 32 for authentication
					$this->_send_cookie($name, base64_encode($key));
				}
				$this->jar_key = $key;
			}

			$this->jar_opened = 1;
		}
	}

	private function jar_close()
	{
		if ($this->jar_fd)
		{
			flock($this->jar_fd, LOCK_UN);
			fclose($this->jar_fd);
			$this->jar_fd = null;
		}
	}

	private function jar_pathname($create = false)
	{
		if (strlen($id = $this->id) < 4)
		{
			return false;
		}

		$path = Ut::join_path($this->save_path, $this->name . substr($id, 0, 1), substr($id, 1, 2), substr($id, 3));

		clearstatcache();
		if (@file_exists($path))
		{
			if (@is_writeable($path) && !is_link($path) && is_file($path))
			{
				return $path;
			}
		}
		else if ($create)
		{
			$dir = dirname($path);
			if ((@file_exists($dir) && is_writeable($dir) && is_dir($dir))
				|| mkdir($dir, ((($this->save_mode >> 2) & 0111) | $this->save_mode), true))
			{
				return $path;
			}
		}

		return false;
	}

	private function jar_open_file()
	{
		if ($this->jar_fd && $this->jar_id === $this->id)
		{
			rewind($this->jar_fd);
			$this->jar_stat = fstat($this->jar_fd);
			return true;
		}

		$this->jar_close();

		if (($fname = $this->jar_pathname(true)))
		{
			if (($fd = fopen($fname, 'c+b')))
			{
				// check for evil symlinks..
				if (flock($fd, LOCK_EX) && ($this->jar_stat = fstat($fd)))
				{
					$this->jar_fd = $fd;
					$this->jar_id = $this->id;
					chmod($fname, $this->save_mode);
					return true;
				}

				fclose($fd);
				// unlink?
			}
		}

		return false;
	}

	private function jar_destroy()
	{
		$this->jar_close();
		if (($fname = $this->jar_pathname()))
		{
			unlink($fname);
		}
	}

	private function jar_read()
	{
		if (!$this->jar_pathname())
		{
			// here we generate new session id for utterly new, or stale/evil id offered by client
			$this->set_new_id();
			$this->active = true;
		}

		if (($this->jar_open_file()))
		{
			if (($size = $this->jar_stat['size']) == 0)
			{
				return '';
			}

			if (($text = fread($this->jar_fd, $size)) !== false
				&& strlen($text) == $size)
			{
				if ($text)
				{
					$text = $this->decrypt($text);
					$text and $text = gzinflate($text);
				}
				return $text;
			}
			// error
		}

		return false;
	}

	private function jar_write($text)
	{
		if (($this->jar_open_file()))
		{
			$text = gzdeflate($text, 9);
			$text = $this->encrypt($text);

			$size = strlen($text);

			if ($size < $this->jar_stat['size'])
			{
				ftruncate($this->jar_fd, $size);
			}

			if (fwrite($this->jar_fd, $text, $size) == $size)
			{
				return true;
			}
			// error
		}

		return false;
	}

	private function jar_gc()
	{
		// STS: session files bound to session cookie name, so hope that ONE session name will be used in each run ;)
		$lvl1 = [];
		$preflen = strlen($this->name);
		foreach ((array) scandir($this->save_path, SCANDIR_SORT_NONE) as $file)
		{
			if (!strncmp($file, $this->name, $preflen) && strlen($file) == $preflen + 1)
			{
				$lvl1[] = $file;
			}
		}
		shuffle($lvl1);

		$lvl2 = [];
		foreach ($lvl1 as $l1)
		{
			$l1p = Ut::join_path($this->save_path, $l1);
			foreach ((array) scandir($l1p, SCANDIR_SORT_NONE) as $file)
			{
				if (fnmatch('[0-9a-zA-Z][0-9a-zA-Z]', $file))
				{
					$lvl2[] = $l1p . '/' . $file;
				}
			}
			if (count($lvl2) > 500) break;
		}
		shuffle($lvl2);

		$nstats = $ndels = 0;
		$past = time() - $this->gc_maxlifetime;
		foreach ($lvl2 as $l2)
		{
			$stats = $dels = 0;
			foreach ((array) scandir($l2, SCANDIR_SORT_NONE) as $file)
			{
				if ($file[0] == '.') continue;
				$full = $l2 . '/' . $file;
				++$stats;
				++$nstats;
				if (filemtime($full) < $past && unlink($full))
				{
					++$dels;
					++$ndels;
				}
			}
			if ($stats == $dels)
			{
				rmdir($l2);
			}
			if ($nstats > 600 || $ndels > 100) break;
		}
		Ut::dbg('gc', $nstats, $ndels);

		return $ndels;
	}

	// session store encryption	  ====================================================
	// done by Enrico Zimuel (https://github.com/ezimuel/PHP-Secure-Session)
	protected function encrypt($data)
	{
		if ($this->jar_key)
		{
			$iv = Ut::random_bytes(16); // AES block size in CBC mode
			// Encryption
			$ciphertext = openssl_encrypt(
				$data,
				'AES-256-CBC',
				mb_substr($this->jar_key, 0, 32, '8bit'),
				OPENSSL_RAW_DATA,
				$iv
			);
			// Authentication
			$hmac = hash_hmac(
				'SHA256',
				$iv . $ciphertext,
				mb_substr($this->jar_key, 32, null, '8bit'),
				true
			);
			$data = $hmac . $iv . $ciphertext;
		}
		return $data;
	}

	protected function decrypt($data)
	{
		if ($this->jar_key)
		{
			$hmac		= mb_substr($data, 0, 32, '8bit');
			$iv			= mb_substr($data, 32, 16, '8bit');
			$ciphertext = mb_substr($data, 48, null, '8bit');
			// Authentication
			$hmacNew = hash_hmac(
				'SHA256',
				$iv . $ciphertext,
				mb_substr($this->jar_key, 32, null, '8bit'),
				true
			);
			if (!$this->hash_equals($hmac, $hmacNew))
			{
				return false; // authentication failed
			}
			// Decrypt
			$data = openssl_decrypt(
				$ciphertext,
				'AES-256-CBC',
				mb_substr($this->jar_key, 0, 32, '8bit'),
				OPENSSL_RAW_DATA,
				$iv
			);
		}
		return $data;
	}

	protected function hash_equals($expected, $actual)
	{
		$expected	  = (string) $expected;
		$actual		  = (string) $actual;
		if (function_exists('hash_equals'))
		{
			return hash_equals($expected, $actual); // since 5.6.0
		}
		$lenExpected  = mb_strlen($expected, '8bit');
		$lenActual	  = mb_strlen($actual, '8bit');
		$len		  = min($lenExpected, $lenActual);
		$result = 0;
		for ($i = 0; $i < $len; $i++)
		{
			$result |= ord($expected[$i]) ^ ord($actual[$i]);
		}
		$result |= $lenExpected ^ $lenActual;
		return ($result === 0);
	}
}
